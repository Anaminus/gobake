package main

import (
	"bytes"
	"compress/gzip"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
)

const preamble = `// File generated by "gobake %s"
// DO NOT EDIT!

package %s

import "strings"
import "io"
import "%s"
`

const function = `
func %s() io.ReadCloser {
	const a = "" +
%s
	%s
}
`

const comp = `gr, _ := gzip.NewReader(strings.NewReader(a))
	return gr`

const nocomp = `return ioutil.NopCloser(strings.NewReader(a))`

func main() {
	var compress bool
	var export bool
	var pkg string
	var output string
	flag.BoolVar(&compress, "compress", false, "gzip-compress the content of the file")
	flag.BoolVar(&export, "export", false, "export the resulting functions")
	flag.StringVar(&pkg, "package", "main", "the name of the package")
	flag.StringVar(&output, "output", "_bake.go", "the file to write to")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "usage: %s [file ...]:\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	file, err := os.Create(output)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer file.Close()

	if compress {
		write(file, preamble, strings.Join(os.Args[1:], " "), pkg, "compress/gzip")
	} else {
		write(file, preamble, strings.Join(os.Args[1:], " "), pkg, "io/ioutil")
	}
	for _, name := range flag.Args() {
		if compress {
			write(file, function, getFuncName(name, export), readFile(name, true), comp)
		} else {
			write(file, function, getFuncName(name, export), readFile(name, false), nocomp)
		}
	}
}

func write(f *os.File, s string, v ...interface{}) {
	if _, err := fmt.Fprintf(f, s, v...); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func getFuncName(name string, export bool) string {
	s := []rune{}
	for _, r := range name {
		switch {
		case unicode.IsLetter(r):
			if len(s) == 0 {
				if export {
					s = append(s, unicode.ToUpper(r))
				} else {
					s = append(s, unicode.ToLower(r))
				}
			} else {
				s = append(s, r)
			}
		default:
			if len(s) > 0 {
				s = append(s, '_')
			}
		}
	}
	return string(s)
}

func readFile(name string, compress bool) string {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if compress {
		buf := bytes.NewBuffer(nil)
		gw := gzip.NewWriter(buf)
		if _, err := gw.Write(b); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		if err := gw.Close(); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		b = buf.Bytes()
	}
	s := []byte{}
	for i := 0; i < len(b); i++ {
		if i%16 == 0 {
			s = append(s, '\t', '\t', '"')
		}
		s = append(s, '\\', 'x', 0, 0)
		hex.Encode(s[len(s)-2:len(s)], b[i:i+1])
		if i == len(b)-1 {
			s = append(s, '"', '\n')
		} else if i%16 == 15 {
			s = append(s, '"', ' ', '+', '\n')
		}
	}
	return string(s)
}
